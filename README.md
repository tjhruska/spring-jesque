SpringJesque
==================
SpringJesque supports the integration of the [Jesque](https://github.com/gresrun/jesque) project into your existing Spring application.  It depends on Jesque version 2.0.1 or greater.  Jesque has added support for JobFactories which allow for the injection of behavior on how to materialize jobs.  These changes have allowed for utilization of bean jobs without having to make any changes to the existing Jesque Worker classes.

With SpringJesque v1.0.3 LoggingProxy[Runnable|Callable] has been added as a possible wrapper to the jobs materialized using the BeanJobFactory.  This will allow for logging start and stopping of jobs with timings, as well as logging of the exception when a job throws an exception.

Configuring Jesque to run within Spring Context Life-cycle Manager
------------------
SpringJesque allows for the wiring up of SpringConfiguredJesqueServer that can contain multiple JesqueContainer beans.  Each JesqueContainer beans can manage multiple workers as generated by a worker factory.  These workers can be any implementation of the Worker interface.  Both SpringConfiguredJesqueServer and JesqueContainer allow for a wide array of jesque processing server configurations.

```xml
<bean id="jesqueServer" class="com.tjhruska.spring.jesque.SpringConfiguredJesqueServer">
    <constructor-arg>
        <list>
            <bean class="com.tjhruska.spring.jesque.JesqueContainer">
                <constructor-arg ref="workerImplFactory1" /> <!-- this factory creates workers tied to the configured queues -->
            </bean>
            <bean class="com.tjhruska.spring.jesque.JesqueContainer">
                <constructor-arg ref="workerImplFactory2" /> <!-- each factory can create whatever type of Worker is needed -->
            </bean>
        </list>
    </constructor-arg>
</bean>
```
See unit tests for futher wiring examples

Run Bean Jobs within Jesque
------------------
By using BeanJobFactory (implementation of JobFactory), and BeanJob it is easy to configure beans jobs that can be executed as jesque jobs.  BeanJobFactory can materialize job from jesque to instances of Runnable or RunnableWithInit.

Non bean jobs can also be executed by injecting an alternate JobFactory into the BeanJobFactory to handle the non bean jobs.  BeanJob can be used for easy enqueing of bean jobs into jesque.

Bean jobs can be any class that implements either Runnable or RunnableWithInit.  RunnableWithInit is an interface that BeanJobFactory can use to load arguments into the bean job before execution.

```xml
<bean id="beanJobFactory" class="com.tjhruska.spring.jesque.BeanJobFactory" /> <!-- inject a fallbackJobFactory to also handle non bean jobs -->
    
<bean id="testBeanJob" class="com.tjhruska.spring.jesque.testJobs.TestBeanJob" scope="prototype" /> <!-- jobs can be prototype for thread safety -->
<bean id="testInitializingBeanJob" class="com.tjhruska.spring.jesque.testJobs.TestInitializingBeanJob" scope="prototype" />  <!-- this job implements RunnableWithInit for passing in arguments to the job -->
<bean id="testSingletonBeanJob" class="com.tjhruska.spring.jesque.testJobs.TestBeanJob" /> <!-- singleton jobs can also be used -->
```

Distributed network of Jesque and Redis Servers
------------------
For complex distributed jesque systems JesqueJobTransporter has the ability to move jobs from one redis database to another redis database.

```java
public JesqueJobTransporter(JedisPool sourceJedisPool, String sourceQueueName, JedisPool destJedisPool, 
    String destQueueName, String queueNamePrefix, Integer destinationLimit) {
  this.sourceJedisPool = sourceJedisPool;
  this.sourceQueueName = sourceQueueName;
  this.destJedisPool = destJedisPool;
  this.destQueueName = destQueueName;
  this.queueNamePrefix = queueNamePrefix;
  this.destinationLimit = destinationLimit;
}
```

Map Limited Resources to Workers to manage resources needed to execute jobs
------------------
WorkerExitOnEmpty is a worker that will shutdown when its queues are empty.  In some situations a limited resource may need to be utilized in order to process jobs from a queue.  (eg: credentials to an external system which is rate limited to either a limited number of open connections total across all connections, or where the credentials can only be utilized by checking them out.)  I have modeled this limited resource by creating a separate queue per resource, and having a worker shutdown when there are no further jobs to process.  The worker factory can be in charge of the limited resource, and only allocate workers according to limitations.

To utilize WorkerExitOnEmpty just create a WorkerFactory that returns this type of worker, and assigns it to the correct queue tied to the resource.  It is assumed that the jobs on the queue itself will be responsible for allocating and deallocating the limited resource.
